analyze the 2015, 2016, and 2017 World Happiness Reports.
answer the following question:
Did world happiness increase, decrease, or stay about the same from 2015 to 2017?
each country a happiness score based on a poll question that asks respondents to rank their life on a scale of 0 - 10, 
so "world happiness" refers to this definition specifically.

1. We've already read the World_Happiness_2015.csv file into a dataframe called happiness2015.
Use the pandas.read_csv() function to read the World_Happiness_2016.csv file into a dataframe 
called happiness2016 and the World_Happiness_2017.csv file into a dataframe called happiness2017.
Add a column called Year to each dataframe with the corresponding year. For example, the Year column 
in happiness2015 should contain the value 2015 for each row.
https://www.geeksforgeeks.org/adding-new-column-to-existing-dataframe-in-pandas/
https://www.geeksforgeeks.org/python-pandas-dataframe-assign/

import pandas as pd
happiness2015 = pd.read_csv("World_Happiness_2015.csv")
happiness2016 = pd.read_csv("World_Happiness_2016.csv")
happiness2017 = pd.read_csv("World_Happiness_2017.csv")
happiness2015['Year'] = 2015
happiness2016['Year'] = 2016
happiness2017['Year'] = 2017


2. pd.concat()
Let's start by exploring the pd.concat() function. The concat() function combines dataframes one of two ways:
                            side by side axis = 1 == df1 df2 df3 

stacked axis = o  
df1 
df2
df3

pd.concat([df1,df2])

Below are the subsets we'll be working with:
head_2015 = happiness2015[['Country','Happiness Score', 'Year']].head(3)
head_2016 = happiness2016[['Country', 'Happiness Score','Year']].head(3)

We've already saved the subsets from happiness2015 and happiness2016 to the variables head_2015 and head_2016.
Use the pd.concat() function to combine head_2015 and head_2016 along axis = 0. Remember to pass the head_2015 and head_2016 into the function as a list. Assign the result to concat_axis0.
Use the pd.concat() function to combine head_2015 and head_2016 along axis = 1. Remember to pass head_2015 and head_2016 into the function as a list and set the axis parameter equal to 1. Assign the result to concat_axis1.
Use the variable inspector to view concat_axis0 and concat_axis1.
Assign the number of rows in concat_axis0 to a variable called question1.
Assign the number of rows in concat_axis1 to a variable called question2.

head_2015 = happiness2015[['Country','Happiness Score', 'Year']].head(3)
head_2016 = happiness2016[['Country','Happiness Score', 'Year']].head(3)
concat_axis0 = pd.concat([head_2015,head_2016],axis = 0)

concat_axis1 =pd.concat([head_2015,head_2016],axis = 1)

question1 = concat_axis0.shape[0]

question2 = concat_axis1.shape[0]

https://i.stack.imgur.com/3FXuI.png -- DataFrame.count(self, axis=0, level=None, numeric_only=False)[source]
total_rows=len(df.axes[0])
total_cols=len(df.axes[1])
row counts len(df),df.shape[0],len(df.index)
column counts len(def.columns), df.shape[1]
group count- df.count, df.sixe

3. We've already created the head_2015 and head_2016 variables.
Use the pd.concat() function to combine head_2015 and head_2016 along axis = 0. Remember to pass the head_2015 and head_2016 into the function as a list. Assign the result to concat_axis0.
Use the variable inspector to view concat_axis0.
Assign the number of rows in concat_axis0 to a variable called rows.
Assign the number of columns in concat_axis0 to a variable called columns.


head_2015 = happiness2015[['Year','Country','Happiness Score', 'Standard Error']].head(4)
head_2016 = happiness2016[['Country','Happiness Score', 'Year']].head(3)

concat_axis0 = pd.concat([head_2015,head_2016], axis = 0)
rows = len(concat_axis0.axes[0])
columns = len(concat_axis0.axes[1])
	Country	Happiness Score	Standard Error	Year
0	Switzerland	7.587	0.03411	2015
1	Iceland	7.561	0.04884	2015
2	Denmark	7.527	0.03328	2015
3	Norway	7.522	0.03880	2015
0	Denmark	7.526	NaN	2016
1	Switzerland	7.509	NaN	2016
2	Iceland	7.501	NaN	2016

Note that because the Standard Error column didn't exist in head_2016, NaN values
were created to signify those values are missing.
ignore_index.....
Luckily, the concat function has a parameter, ignore_index, that can be used to clear the existing
index and reset it in the result.
head_2015 = happiness2015[['Year','Country','Happiness Score', 'Standard Error']].head(4)
head_2016 = happiness2016[['Country','Happiness Score', 'Year']].head(3)
concat_update_index = pd.concat([head_2015,head_2016],axis = 0 , ignore_index = True)

5. pd.merge() function ---a function that can execute high performance database-style joins
the merge function only combines dataframes horizontally (axis=1) and can only combine two dataframes at a time. 
valuable when we need to combine very large dataframes quickly
With the merge() function, we'll combine dataframes on a key, a shared index or column.
pd.merge(left = df1, right = df2, on 'Col_Name')

We've already saved three rows from happiness2015 and happiness2016 to variables named three_2015 and three_2016.
Use the pd.merge() function to join three_2015 and three_2016 on the Country column. Assign the result to merged.
three_2015 = happiness2015[['Country','Happiness Rank','Year']].iloc[2:5]
three_2016 = happiness2016[['Country','Happiness Rank','Year']].iloc[2:5]
merged = pd.merge(left=three_2015, right = three_2016, on = "Country" )

Joining three_2015 and three_2016 in the last exercise resulted in a dataframe with just one row:
Country	Happiness Rank_x	Year_x	Happiness Rank_y	Year_y
0	Norway	4	2015	4	2016
Let's look back to three_2015 and three_2016 to understand why. Since we joined the dataframes on the Country column,
or used it as the key, the merge() function looked to match elements in the Country column in BOTH dataframes.
his way of combining, or joining, data is called an inner join. An inner join returns only the intersection of the keys, 
or the elements that appear in both dataframes with a common key.

There are actually four different types of joins:

Inner: only includes elements that appear in both dataframes with a common key
Outer: includes all data from both dataframes
Left: includes all of the rows from the "left" dataframe along with any rows from the "right" dataframe with a common key; 
the result retains all columns from both of the original dataframes
Right: includes all of the rows from the "right" dataframe along with any rows from the "left" dataframe with a common key; 
the result retains all columns from both of the original dataframes

Update merged to use a left join instead of an inner join. Set the how parameter to 'left' in merge(). Assign the result to merged_left.
Update merged_left so that the left parameter equals three_2016 and the right parameter equals three_2015. Assign the result to merged_left_updated.
Based on the results of this exercise, when using a left join, does changing the dataframe assigned to the left and right parameters change the result? 
Try to answer this question before moving onto the next screen.
three_2015 = happiness2015[['Country','Happiness Rank','Year']].iloc[2:5]
three_2016 = happiness2016[['Country','Happiness Rank','Year']].iloc[2:5]
merged = pd.merge(left=three_2015, right=three_2016, on='Country')
merged_left = pd.merge(left=three_2015, right=three_2016, on='Country', how = 'left')
merged_left_updated = pd.merge(right=three_2015,left = three_2016, on='Country', how = 'left')

